-- @atlcompiler emftvm
-- @nsURI JSchemaMM=http://at.jku.bise/jsonMetaschemaMM
-- @nsURI Ecore=http://www.eclipse.org/emf/2002/Ecore
-- @nsURI JsonGrammarMM=http://at.jku.bise/jsongrammar/1.0
-- @nsURI RelatedSchemasMM=http://at.jku.bise/relatedSchemas
-- @nsURI JsonMM=http://at.jku.bise/jsonMM
-- @nsURI CompleteOclMM=http://www.eclipse.org/ocl/2015/CompleteOCLCS


module JsonSchema2EcoreOpt; 
--create ecoreM : Ecore, jsonGrammar : JsonGrammarMM, jschemaOut: JSchemaMM from jschema : JSchemaMM;
create ecoreM : Ecore, jsonGrammar : JsonGrammarMM, relatedSchemas : RelatedSchemasMM   from jschema : JSchemaMM, jsonMM:JsonMM ;


uses JsonSchema2EcoreOptUtils;

helper def: rootEPackage : Ecore!EPackage = OclUndefined;
helper def: jsonDocumentStarter:String='jsonDocumentStarter';
helper def: packageName : String = thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().lastSegment();
helper def: nsURI : String = 'http://jku.bise.at/' + thisModule.packageName;

--helper def: oclFileName:String  =thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().path().concat('-opt');
helper def: oclFileUri: OclAny = thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension();

rule JsonSchemaToEPackage {
	from
		jsonSchema : JSchemaMM!JsonSchema
	to 
		ePackage : Ecore!EPackage (
			name <- thisModule.packageName,
			nsPrefix <- thisModule.packageName,
			nsURI <- thisModule.nsURI
		),
		jsonGrammar : JsonGrammarMM!JsonGrammar (
			nsURI <- thisModule.nsURI,
			detailedGrammar <- detailedGrammar
		), 
		detailedGrammar : JsonGrammarMM!DetailedGrammar (),
		relatedSchemas : RelatedSchemasMM!RelatedSchemas()
	do {
		---------- Create ocl file -----
		thisModule.createOclFile();
	}
}

---------TODO Map case when the root is a boolean schema
--rule mapRootBooleanSchemaTrueToJsonDocument{
--	from booleanSchema: JSchemaMM!BooleanSchema(booleanSchema.refImmediateComposite().oclIsTypeOf(JSchemaMM!JsonSchema) and booleanSchema.value=true)
--	to jsonDocument: JSchemaMM!JsonDocument
--}

abstract rule mapSchemaToEClass{ 
	from schema : JSchemaMM!Schema
	using {
		eClassName:String = schema.buildEClassname(); ---we don't need to concat 'Items' because the class is being generated from the schema inside items. So the buildEClassname has alredy 'Items' concatenated
	}
	to 
		eClass : Ecore!EClass (
			name<- eClassName,
			eStructuralFeatures <- eClass.eStructuralFeatures 
				-> union (	if schema.isInAdditionalProperties()  or schema.isKeySchemaPairInPatternProperties()
							then Sequence{thisModule.createKeyEAttribute('key')}
							else Sequence{}
							endif)
		)
	do{
		if(schema.isKeySchemaPairInProperties() or schema.isKeySchemaPairInPatternProperties() ){
			eClass.eSuperTypes <-  Sequence{thisModule.createAbstractEClass(schema.refImmediateComposite().refImmediateComposite().refImmediateComposite().buildPropertiesAbstractClassName())};
			if(schema.isKeySchemaPairInPatternProperties()){
				eClass.eAnnotations <- Sequence{thisModule.createPatternPropertiesAnnotation(schema.refImmediateComposite().key)};
				eClass.eOperations <- Sequence{thisModule.createPatternPropertiesMatcher(schema.refImmediateComposite().key), 
												thisModule.createKeyPatternPropertiesMatcher(schema.refImmediateComposite().key),
												thisModule.createValidatorOnPatternProperties(schema.refImmediateComposite().refImmediateComposite().findPatternPropertiesKeysOtherThen(schema.refImmediateComposite().key)),
												thisModule.createValidatorOnProperties(schema.refImmediateComposite().refImmediateComposite().refImmediateComposite().findPropertiesKeys())
										};
				thisModule.appendValidatorOnProperties(thisModule.packageName, eClassName, eClassName);
				thisModule.appendValidatorOnPatternProperties(thisModule.packageName, eClassName, eClassName);
--				eClass.eOperations <- Sequence{thisModule.createPatternPropertiesMatcher(schema.refImmediateComposite().key)};
			}	
		}else if(schema.refImmediateComposite().oclIsTypeOf(JSchemaMM!AdditionalPropertiesSchemaDefinition)){ ----- schema is in AdditionalProperties
			eClass.eSuperTypes <-  Sequence{thisModule.createAbstractEClass(schema.refImmediateComposite().refImmediateComposite().buildPropertiesAbstractClassName() )};
			eClass.eAnnotations <- Sequence{thisModule.createAdditionalPropertiesAnnotation()};
			eClass.eOperations <- Sequence{thisModule.createValidatorOnPatternProperties(schema.refImmediateComposite().refImmediateComposite().findPatternPropertiesKeys()),
											thisModule.createValidatorOnProperties(schema.refImmediateComposite().refImmediateComposite().findPropertiesKeys())};
			
			thisModule.appendValidatorOnProperties(thisModule.packageName, eClassName, eClassName);
			thisModule.appendValidatorOnPatternProperties(thisModule.packageName, eClassName, eClassName);								
			
		}
		if(schema.isRoot()){
			thisModule.jsonGrammarRoot().detailedGrammar.rootEClass <- schema;
		}	
	}	
} 

--rule createAdditionalPropertiesValidatorOnPatternProperties(properties : Sequence(String), patterns: Sequence(String)){
	
rule createValidatorOnProperties(properties: Sequence(String)){
	to
		eOperation:Ecore!EOperation(
			name<- 'validateKeyOnDefinedProperties',
			ordered <- false,
			unique <-false,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EString, --- the additional property key can not be equals to the defined property
			eAnnotations <- Sequence{eAnnotation}
		),
		eAnnotation: Ecore!EAnnotation(
			source <- 'http://www.eclipse.org/emf/2002/GenModel',
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
			key <- 'body',
			value <-  thisModule.createBodyForValidateKeyOnDefinedProperties(properties)
		)
	do{
		eOperation;
	}
		
}	
	
	
rule createValidatorOnPatternProperties(patterns: Sequence(String)){
	to
		eOperation:Ecore!EOperation(
			name<- 'validateKeyOnDefinedPatternProperties',
			ordered <- false,
			unique <-false,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EString, --- the additional property key can not match the defined pattern property
			eAnnotations <- Sequence{eAnnotation}
		),
		eAnnotation: Ecore!EAnnotation(
			source <- 'http://www.eclipse.org/emf/2002/GenModel',
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
			key <- 'body',
			value <-  thisModule.createBodyForValidateKeyOnDefinedPatternProperties(patterns)
		)
	do{
		eOperation;
	}
}

rule createAdditionalPropertiesAnnotation(){
	to
		eAnnotation: Ecore!EAnnotation(
			source <- thisModule.ADDITIONAL_PROPERTIES,
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
--			key <- 'AdditionalProperties',
			key <- thisModule.ADDITIONAL_PROPERTIES,
			value <- 'true'
		)
	do{
		eAnnotation;
	}	
}

rule createKeyPatternPropertiesMatcher(pattern : String){
	to
		eOperation:Ecore!EOperation(
			name<- 'find',
			ordered <- false,
			unique <-false,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EBoolean,
			eAnnotations <- Sequence{eAnnotation}
		),
		eAnnotation: Ecore!EAnnotation(
			source <- 'http://www.eclipse.org/emf/2002/GenModel',
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
			key <- 'body',
			value <- 'java.util.regex.Pattern  p = java.util.regex.Pattern.compile('+pattern+');\njava.util.regex.Matcher m = p.matcher(this.key);\nreturn m.find();'
		)
		
	do{
		eOperation;
	}	
}

rule createPatternPropertiesMatcher(pattern : String){
	to
		eOperation:Ecore!EOperation(
			name<- 'find',
			ordered <- false,
			unique <-false,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EBoolean,
			eParameters <- Sequence{eParameter},
			eAnnotations <- Sequence{eAnnotation}
		),
		eParameter:Ecore!EParameter(
			name<-'toBeEvaluated',
			eType <- Ecore!EString,
			lowerBound <- 1,
			upperBound <- 1
		),
		eAnnotation: Ecore!EAnnotation(
			source <- 'http://www.eclipse.org/emf/2002/GenModel',
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
			key <- 'body',
			value <- 'java.util.regex.Pattern  p = java.util.regex.Pattern.compile('+pattern+');\njava.util.regex.Matcher m = p.matcher(toBeEvaluated);\nreturn m.find();'
		)
		
	do{
		eOperation;
	}	
}

rule createPatternPropertiesAnnotation(pattern : String){
	to
		eAnnotation: Ecore!EAnnotation(
			source <- thisModule.PATTERN_PROPERTIES,
			details <- Sequence{entrySet1, entrySet2}
		),
		entrySet1:Ecore!EStringToStringMapEntry(
--			key <- 'PatternProperties',
			key <- thisModule.PATTERN_PROPERTIES,
			value <- 'true'
		),
		entrySet2:Ecore!EStringToStringMapEntry(
			key <- 'pattern',
			value <- pattern
		)
		
	do{
		eAnnotation;
	}	
}


rule createKeywordAnnotation(keyword:String){
	to
		eAnnotation: Ecore!EAnnotation(
			source <- thisModule.KEYWORD,
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
			key <- thisModule.KEYWORD,
			value <- keyword
		)
	do{
		eAnnotation;
	}	
}

---------------------------------------------

rule mapBooleanSchemaToEClass extends mapSchemaToEClass{
--	from schema: JSchemaMM!BooleanSchema(not schema.refImmediateComposite().oclIsTypeOf(JSchemaMM!JsonSchema) and schema.value=true)
	from schema: JSchemaMM!BooleanSchema( schema.value=true)
	to 
		eClass : Ecore!EClass
	do{ --- we have to assign eStructuralFeatures in the imperative block, because the union wouldn't work, if a part if different features are added from the two targets of the abstract and concrete rule
--		eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createContainmentToJsonDocument(schema.getKey(), schema.isKeySchemaPairInProperties())});
		eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createContainmentToJsonDocument(schema.getKey(), schema.needsKeyword())});
	}
}
			
rule mapObjectSchemaToEClass extends mapSchemaToEClass{
	from schema : JSchemaMM!ObjectSchema
	to 
		eClass : Ecore!EClass
	do{ 
		if(not schema.ref.oclIsUndefined()){ --- "$ref" is present
			eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{schema.ref});
		}else if (not schema.enum.oclIsUndefined()){ --- "enum" is present
			
			----- TODO implement
			
		}else if (schema.type.oclIsUndefined()){  ---- "type" is missing
			eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createContainmentForArrayOfTypes(schema, eClass, Sequence{#"\"string\"", #"\"integer\"", #"\"number\"", #"\"boolean\"", #"\"object\"", #"\"array\"", #"\"null\""} )});
		}else if(schema.hasSimpleType()){
			thisModule.mapSimpleTypeToEStructuralFeatures(schema, eClass , schema.type.anyOf.type, eClass.name); 
		}else if(schema.hasArrayOfTypes){ ----"type" is present and  is and array of "types" : "type":[...]
			eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createContainmentForArrayOfTypes(schema, eClass, schema.type.anyOf.items )});
		}
	}
}



---- schema objectSchema having the "type" keyword
---- eClass  -----  EClass that is mapped to objectSchema having the "type" keyword
---- simpleType:JSchemaMM!SimpleTypes, ----- the simple type we are mapping to the eStructuralFeature
----- eClassName eClass.name. It could be thant eClass.name is not set yet
rule mapSimpleTypeToEStructuralFeatures(schema : JSchemaMM!ObjectSchema, eClass : Ecore!EClass, simpleType:JSchemaMM!SimpleTypes, eClassName:String)  {
	
	do{
		if (simpleType = #"\"string\"" or simpleType = #"\"integer\"" or simpleType = #"\"number\"" or  simpleType = #"\"boolean\""){ 
--			eClass.eStructuralFeatures  <- eClass.eStructuralFeatures -> union(Sequence{thisModule.mapScalarTypeToEAttribute(schema.getKey(),thisModule.scalarTypeMapping.get(simpleType), schema.isKeySchemaPairInProperties())});
			eClass.eStructuralFeatures  <- eClass.eStructuralFeatures -> union(Sequence{thisModule.mapScalarTypeToEAttribute(schema.getKey(),thisModule.scalarTypeMapping.get(simpleType), schema.needsKeyword())});
		}else if(simpleType = #"\"object\"" ){
--			eClass.eStructuralFeatures <- eClass.eStructuralFeatures-> union(Sequence{thisModule.createPropertiesContainment(schema.getKey(), schema.buildPropertiesAbstractClassName(), schema.isKeySchemaPairInProperties())});
--			eClass.eStructuralFeatures <- eClass.eStructuralFeatures-> union(Sequence{thisModule.createPropertiesContainment(schema.getKey(), schema.buildPropertiesAbstractClassName(), schema.needsKeyword())});
			eClass.eStructuralFeatures <- eClass.eStructuralFeatures-> union(Sequence{thisModule.createPropertiesContainment(schema.getKeyForPropertiesContainment(), schema.buildPropertiesAbstractClassName(), schema.needsKeyword(), schema.getKey())});
			if(schema.additionalProperties.oclIsUndefined()){ ------ the keyword "additionalProperties" is missing
--				thisModule.createDefaultAdditionalPropertiesEClass(schema.buildEClassname());
				thisModule.createDefaultAdditionalPropertiesEClass(schema.buildEClassname(), schema.findPropertiesKeys(),  schema.findPatternPropertiesKeys());
			}
		}else if (simpleType = #"\"array\""){  
			if(schema.items.oclIsUndefined()) {---the keyword "items" is missing
--				eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createEClassForMissingItems(schema.buildEClassname(), schema.getKey(), schema.isKeySchemaPairInProperties())});
				eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createEClassForMissingItems(schema.buildEClassname(), schema.getKey(), schema.needsKeyword())});
			}else if(schema.items.anyOf.oclIsTypeOf(JSchemaMM!ItemsAnyOf1)){ ---- the keyword "items" is present and is not a tuple
				eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{schema.items.anyOf});
			}else{ ---- the keyword "items" is present and is a tuple 
				
				-----TODO Implement
				
			}
		}else if(simpleType = #"\"null\""){ ------- "type" is present and "type": "null"
--			eClass.eStructuralFeatures  <- eClass.eStructuralFeatures -> union(Sequence{thisModule.mapNullTypeToEReference(schema.getKey(), schema.isKeySchemaPairInProperties())});
			eClass.eStructuralFeatures  <- eClass.eStructuralFeatures -> union(Sequence{thisModule.mapNullTypeToEReference(schema.getKey(), schema.needsKeyword())});
		}
	}
}





lazy rule mapNullTypeToEReference{
	from name : String, addToKeywords:Boolean
	to 
		eAttribute : Ecore!EReference (
			name<-name,
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1,
--			eType <- JSchemaMM!NullValue,
			eType <- JsonMM!NullValue,
			eAnnotations <- eAttribute.eAnnotations -> union (if addToKeywords then Sequence{thisModule.createKeywordAnnotation(name)} else Sequence{} endif)
		)
	do{ 
		if(addToKeywords){ 
			thisModule.keywords <- thisModule.keywords->union(Sequence{eAttribute}) ;
		}
		eAttribute;
	}
}

lazy rule mapScalarTypeToEAttribute{
	from name : String, eType:Ecore!EDataType, addToKeywords:Boolean
	to 
		eAttribute : Ecore!EAttribute(
			name<-name,
			lowerBound <-1,
			upperBound <- 1,
			eType <- eType,
			eAnnotations <- eAttribute.eAnnotations -> union (if addToKeywords then Sequence{thisModule.createKeywordAnnotation(name)} else Sequence{} endif)
			
		)
	do{ 
		if(addToKeywords){ 
			thisModule.keywords <- thisModule.keywords->union(Sequence{eAttribute}) ;
		}
		eAttribute;
	}
}

lazy rule createPropertiesContainment{
	from referenceName:String, propertiesEClassName:String, addToKeywords:Boolean, keyword : String
	to 
		eReference :Ecore!EReference ( 
			name <- referenceName,
			eType <- thisModule.createAbstractEClass(propertiesEClassName),
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1,
			eAnnotations <- eReference.eAnnotations -> union (if addToKeywords then Sequence{thisModule.createKeywordAnnotation(keyword)} else Sequence{} endif)
		)
	do {
		thisModule.curlyBracesEReferences <- thisModule.curlyBracesEReferences->union(Sequence{eReference}); 
		if(addToKeywords){ 
			thisModule.keywords <- thisModule.keywords->union(Sequence{eReference}) ;
		}
		eReference;
	}	
}

lazy rule createDefaultAdditionalPropertiesEClass  {
	from schemaBuildedClassName:String, properties : Sequence(String), patterns : Sequence(String)
	using {
		eClassName:String = schemaBuildedClassName.concat('AdditionalProperties');
	}
	to
		eClass : Ecore!EClass (
--		 	name <-	schemaBuildedClassName.concat('AdditionalProperties'),
			name <-	eClassName,
			eStructuralFeatures <- Set{thisModule.createKeyEAttribute('key'), thisModule.createContainmentToJsonDocument('additionalProperties',false)}.flatten(),
			eSuperTypes <-  Set{thisModule.createAbstractEClass(schemaBuildedClassName.concat('Properties'))},
			eAnnotations <- Sequence{thisModule.createAdditionalPropertiesAnnotation()},
			eOperations <- Sequence{thisModule.createValidatorOnPatternProperties(patterns),thisModule.createValidatorOnProperties(properties)}
		)
	do{
		thisModule.appendValidatorOnProperties(thisModule.packageName, eClassName, eClassName);
		thisModule.appendValidatorOnPatternProperties(thisModule.packageName, eClassName, eClassName);
		eClass;
	}	
}

rule mapItemsAnyOf1ToContainment{
	from itemsAnyOf1:JSchemaMM!ItemsAnyOf1
	using {
		eReferenceName : String = itemsAnyOf1.refImmediateComposite().refImmediateComposite().getKey();
	}
	to 
		eReference :Ecore!EReference ( 
--			name <- itemsAnyOf1.refImmediateComposite().refImmediateComposite().getKey(),
			name <- eReferenceName,
			eType <- itemsAnyOf1.anyOf1,
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1,
			eAnnotations <- eReference.eAnnotations -> union (Sequence{thisModule.createKeywordAnnotation(eReferenceName)})
			
		)
	do{
		thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
	}
}

lazy rule createEClassForMissingItems{
	from enclosingEClassName:String, referenceName:String, addToKeywords:Boolean
	to 
		eClass:  Ecore!EClass (
			name <- enclosingEClassName.concat('Items'),
			eStructuralFeatures <- Sequence{thisModule.createContainmentToJsonDocument(('items'),false)}
		),
		eReference :Ecore!EReference ( 
			name <- referenceName,
			eType <- eClass,
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1,
			eAnnotations <- eReference.eAnnotations -> union (if addToKeywords then Sequence{thisModule.createKeywordAnnotation(referenceName)} else Sequence{} endif)
		)
	do{
		if(addToKeywords){
			thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
		}
		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
		eReference;
	}
	
}


lazy rule createContainmentForArrayOfTypes {
	from objectSchema : JSchemaMM!ObjectSchema, enclosingEClass : Ecore!EClass ,  sympleTypes:Sequence(JSchemaMM!SimpleTypes)
	to 
		eReference :Ecore!EReference ( 
			name <- objectSchema.getKey(),
			eType <- thisModule.createAbstractEClass(enclosingEClass.name),
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1
		)
	do{
		for (sympleType in sympleTypes){ 
				thisModule.createEClassForTypeInArrayOfTypes(objectSchema, enclosingEClass , sympleType);
			}
		eReference;
	}
}


----- objectSchema: objectSchema having the type keyword as arrya of types.  e.g. "type":["string", "number"]
----- enclosingEClass:  name of the EClass that is mapped to objectSchema
----- simpleType: current simpleType in the array of types which we are creating the EClass for
rule createEClassForTypeInArrayOfTypes(objectSchema : JSchemaMM!ObjectSchema, enclosingEClass : Ecore!EClass , simpleType:JSchemaMM!SimpleTypes){
	using {
--		eClassName:String = enclosingEClass.name.concat('Type').concat(thisModule.typeToStringMapping.get(simpleType).toCamelCase());
		eClassName:String = enclosingEClass.buildEClassNameForArrayOfTypes(simpleType);
	}
	to 
		eClass : Ecore!EClass (
			name <- eClassName,
			eAnnotations <- Sequence{thisModule.createArrayOfTypesAnnotation(simpleType)}
		)
	do{
		thisModule.mapSimpleTypeToEStructuralFeatures(objectSchema, eClass , simpleType, eClassName);
--		eClass.eSuperTypes  <- Sequence{enclosingEClass};
		eClass.eSuperTypes  <- Sequence{thisModule.createAbstractEClass(enclosingEClass.name)};
	}
}	

rule createArrayOfTypesAnnotation(simpleType:JSchemaMM!SimpleTypes){
	to
		eAnnotation: Ecore!EAnnotation(
			source <- thisModule.ARRAY_OF_TYPES,
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
--			key <- 'ArrayOfTypes',
			key <- thisModule.ARRAY_OF_TYPES,
--			value <- simpleType.toString().substring(2, simpleType.toString().size()).stripFirstAndLast()
			value <- thisModule.stripSimpleType(simpleType)
		)
	do{
		eAnnotation;
	}	
}

--rule createKeyEAttribute(keyName:String){
lazy rule createKeyEAttribute{
	from keyName:String 
	to 
		key : Ecore!EAttribute(
			name<- keyName,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EString
	) 
	do {
		thisModule.keyValues <- thisModule.keyValues->union(Sequence{key});
		key;
	}
}

lazy rule  createContainmentToJsonDocument{
	from containmentName:String,  addToKeywords:Boolean
	to
		containment: Ecore!EReference(
			name <- containmentName,
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1,
--			eType <- JSchemaMM!JsonDocument,
			eType <- JsonMM!JsonDocument,
			eAnnotations <- containment.eAnnotations -> union (if addToKeywords then Sequence{thisModule.createKeywordAnnotation(containmentName)} else Sequence{} endif)
		)
	do{ 
		if(addToKeywords){ 
			thisModule.keywords <- thisModule.keywords->union(Sequence{containment});
		}
		containment;
	}
}

---------------------------------------------------------------------
---------------------------------------------------------------------
-----------------------------------------------------------------------

---- TODO manage jsonPointerSchema.hasArrayOfTypes
rule mapRefSchemaToEReference{
	from refSchemaDefinition: JSchemaMM!RefSchemaDefinition 
	using {
        jsonPointerSchema : JSchemaMM!Schema = refSchemaDefinition.findSchemaByJsonPointer();
        isJsonPointerSchemaTypeArray : Boolean = 	if jsonPointerSchema.oclIsTypeOf(JSchemaMM!ObjectSchema) then 
--														if jsonPointerSchema.keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition)).first().findSimpleType() = #"\"array\""
														if jsonPointerSchema.hasSimpleTypeArray()
														then true else false endif
													else false
													endif ;
        eReferenceName : String = refSchemaDefinition.refImmediateComposite().getKey();
	} to		
		eReference :Ecore!EReference ( 
--			name <- refSchemaDefinition.refImmediateComposite().getKey(),
			name <- eReferenceName,
--			eType <- refSchemaDefinition.findSchemaByJsonPointer().oclAsType(JSchemaMM!ObjectSchema),
			eType <- refSchemaDefinition.findSchemaByJsonPointer(),
			containment <- true, 
			lowerBound <- 1,
			upperBound <- 1,
			eAnnotations <- eReference.eAnnotations -> union (if refSchemaDefinition.refImmediateComposite().needsKeyword() then Sequence{thisModule.createKeywordAnnotation(eReferenceName)} else Sequence{} endif) 
		)
	do {
		if (isJsonPointerSchemaTypeArray){ 
			thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
--		}if(refSchemaDefinition.refImmediateComposite().isKeySchemaPairInProperties()) { 
		}if(refSchemaDefinition.refImmediateComposite().needsKeyword()) { 
			thisModule.keywords <- thisModule.keywords->union(Sequence{eReference}) ;
		}
	}	
}

--- This is the old :unique lazy rule createPropertiesEClass{ we change the name because we reuse for more 'properties'
unique lazy rule createAbstractEClass{
	from name:String
	to
		eClass : Ecore!EClass (
			name <- name.concat('Abstract'),
			abstract<- true
		)	
}

----------------------- RELATED SCHEMAS

rule mapAllOf{
	from allOfSchemaDefinition:JSchemaMM!AllOfSchemaDefinition
	to 
		allOf:RelatedSchemasMM!AllOf(
			allOfs<-allOfSchemaDefinition.allOf.items
		)
	do	{
		thisModule.createRelatedEnclosingSchema(allOfSchemaDefinition.refImmediateComposite().resolve()).allOf<-allOf;
		allOf;
	}
}

rule mapAnyOf{
	from anyOfSchemaDefinition:JSchemaMM!AnyOfSchemaDefinition
	to 
		anyOf:RelatedSchemasMM!AnyOf(
			anyOfs<-anyOfSchemaDefinition.anyOf.items
		)
	do	{
		thisModule.createRelatedEnclosingSchema(anyOfSchemaDefinition.refImmediateComposite().resolve()).anyOf<-anyOf;
		anyOf;
	}
}

rule mapOneOf{
	from oneOfSchemaDefinition:JSchemaMM!OneOfSchemaDefinition
	to 
		oneOf:RelatedSchemasMM!OneOf(
			oneOfs<-oneOfSchemaDefinition.oneOf.items
		)
	do	{
		thisModule.createRelatedEnclosingSchema(oneOfSchemaDefinition.refImmediateComposite().resolve()).oneOf<-oneOf;
		oneOf;
	}
}

rule mapNot{
	from notSchemaDefinition:JSchemaMM!NotSchemaDefinition
	to 
		notEClass:RelatedSchemasMM!Not(
			not<-notSchemaDefinition.not
		)
	do	{
		thisModule.createRelatedEnclosingSchema(notSchemaDefinition.refImmediateComposite().resolve()).not<-notEClass;
		notEClass;
	}
}

---- This rule has to be lazy, and called from the endpoint because we have to be sure that, in case of array of types the enclosing class (with TypeObject ending) has been created
unique lazy rule mapDependency{
	from dependenciesAdditionalPropertiesAnyOf1:JSchemaMM!SchemaObjectDependenciesAdditionalPropertiesAnyOf1(dependenciesAdditionalPropertiesAnyOf1.refImmediateComposite().refImmediateComposite().refImmediateComposite().hasTypeObject())
	using {
		enclosingEClass: Ecore!EClass = if dependenciesAdditionalPropertiesAnyOf1.refImmediateComposite().refImmediateComposite().refImmediateComposite().hasSimpleTypeObject()
										then dependenciesAdditionalPropertiesAnyOf1.refImmediateComposite().refImmediateComposite().refImmediateComposite().resolve()
										else thisModule.allEClass()->select(eClass | eClass.name= dependenciesAdditionalPropertiesAnyOf1.refImmediateComposite().refImmediateComposite().refImmediateComposite().resolve().buildEClassNameForArrayOfTypes(#"\"object\""))->first()    ---- is array of type
										endif;
	}
	to 
		dependency:RelatedSchemasMM!Dependency(
			dependency <- dependenciesAdditionalPropertiesAnyOf1.anyOf1,
			property <- dependenciesAdditionalPropertiesAnyOf1.refImmediateComposite().key.stripFirstAndLast() 
		) 
	do	{
--		thisModule.createDependencies(enclosingEClass).dependencies->includes(dependency);
		thisModule.createDependencies(enclosingEClass).dependencies<- thisModule.createDependencies(enclosingEClass).dependencies->append(dependency);
--		dependency;
	}
}

unique lazy rule createDependencies{
	from eClass :Ecore!EClass
	to
		dependencies:RelatedSchemasMM!Dependencies(
		)
	do{
		thisModule.createRelatedEnclosingSchema(eClass).dependencies<-dependencies;
		dependencies;
	}	
}

rule mapIf{
	from ifSchemaDefinition:JSchemaMM!IfSchemaDefinition
	do	{
		thisModule.createRelatedIfThenElse(ifSchemaDefinition.refImmediateComposite().resolve()).if<-ifSchemaDefinition.if.resolve();
	}
}

rule mapThen{
	from thenSchemaDefinition:JSchemaMM!ThenSchemaDefinition
	do	{
		thisModule.createRelatedIfThenElse(thenSchemaDefinition.refImmediateComposite().resolve()).then<-thenSchemaDefinition.then.resolve();
	}
}

rule mapElse{
	from elseSchemaDefinition:JSchemaMM!ElseSchemaDefinition
	do	{
		thisModule.createRelatedIfThenElse(elseSchemaDefinition.refImmediateComposite().resolve()).else<-elseSchemaDefinition.else.resolve();
	}
}


unique lazy rule createRelatedIfThenElse{
	from eClass :Ecore!EClass
	to
		ifThenElse:RelatedSchemasMM!IfThenElse(
		)
	do{
		thisModule.createRelatedEnclosingSchema(eClass).ifThenElse<-ifThenElse;
		ifThenElse;
	}	
}

unique lazy rule createRelatedEnclosingSchema{
	from eClass :Ecore!EClass
	to
		enclosingSchema: RelatedSchemasMM!EnclosingSchema(
			enclosingSchema<-eClass
		)  
	do{
--		thisModule.relatedSchemasRoot().enclosingschemas<-thisModule.relatedSchemasRoot().enclosingschemas->union(Sequence{enclosingSchema});
		thisModule.enclosingSchemas <- thisModule.enclosingSchemas ->union(Sequence{enclosingSchema});
		enclosingSchema;
	}	
	
}


-------------------- OCL Generation --------------------------------

lazy rule minimumConstraintToOcl {
	from minimumSchemaDefinition : JSchemaMM!MinimumSchemaDefinition(minimumSchemaDefinition.refImmediateComposite().hasTypeNumeric())
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = minimumSchemaDefinition.refImmediateComposite();
	}
	do {
--		thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().name, enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
		if(enclosingSchema.hasSimpleType()){ ---- we are sure it is numeric because of hasTypeNumeric()
			thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().name, enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
		}else{ 
			if(enclosingSchema.hasTypeInteger()){ 
--				thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().name.concat('TypeInteger'), enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
				thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().buildEClassNameForArrayOfTypes(#"\"integer\""), enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
			}
			if(enclosingSchema.hasTypeNumber()){ 
--				thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().name.concat('TypeNumber'), enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
				thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().buildEClassNameForArrayOfTypes(#"\"number\""), enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
			}
		}
		
	}	
}

lazy rule exclusiveMinimumConstraintToOcl {
	from exclusiveMinimumSchemaDefinition : JSchemaMM!ExclusiveMinimumSchemaDefinition(exclusiveMinimumSchemaDefinition.refImmediateComposite().hasTypeNumeric())
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = exclusiveMinimumSchemaDefinition.refImmediateComposite();
	}
	do {
		if(enclosingSchema.hasSimpleType()){ ---- we are sure it is numeric because of hasTypeNumeric()
			thisModule.appendExclusiveMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().name, enclosingSchema.resolve().name+'ExclusiveMinimum', exclusiveMinimumSchemaDefinition.exclusiveMinimum, enclosingSchema.getKey());
		}else{ 
			if(enclosingSchema.hasTypeInteger()){ 
				thisModule.appendExclusiveMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().buildEClassNameForArrayOfTypes(#"\"integer\""), enclosingSchema.resolve().name+'ExclusiveMinimum', exclusiveMinimumSchemaDefinition.exclusiveMinimum, enclosingSchema.getKey());
			}
			if(enclosingSchema.hasTypeNumber()){ 
				thisModule.appendExclusiveMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().buildEClassNameForArrayOfTypes(#"\"number\""), enclosingSchema.resolve().name+'ExclusiveMinimum', exclusiveMinimumSchemaDefinition.exclusiveMinimum, enclosingSchema.getKey());
			}
		}
		
	}	
}

lazy rule maximumConstraintToOcl {
	from maximumSchemaDefinition : JSchemaMM!MaximumSchemaDefinition(maximumSchemaDefinition.refImmediateComposite().hasTypeNumeric())
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = maximumSchemaDefinition.refImmediateComposite();
	}
	do {
		if(enclosingSchema.hasSimpleType()){ ---- we are sure it is numeric because of hasTypeNumeric()
			thisModule.appendMaximumConstraint(thisModule.packageName, enclosingSchema.resolve().name, enclosingSchema.resolve().name+'Maximum', maximumSchemaDefinition.maximum, enclosingSchema.getKey());
		}else{ 
			if(enclosingSchema.hasTypeInteger()){ 
				thisModule.appendMaximumConstraint(thisModule.packageName, enclosingSchema.resolve().buildEClassNameForArrayOfTypes(#"\"integer\""), enclosingSchema.resolve().name+'Maximum', maximumSchemaDefinition.maximum, enclosingSchema.getKey());
			}
			if(enclosingSchema.hasTypeNumber()){ 
				thisModule.appendMaximumConstraint(thisModule.packageName, enclosingSchema.resolve().buildEClassNameForArrayOfTypes(#"\"number\""), enclosingSchema.resolve().name+'Maximum', maximumSchemaDefinition.maximum, enclosingSchema.getKey());
			}
		}
		
	}	
}


lazy rule requiredInPropertiesToOcl{
	from requiredSchemaDefinition : JSchemaMM!RequiredSchemaDefinition(requiredSchemaDefinition.refImmediateComposite().hasTypeObject() and requiredSchemaDefinition.refImmediateComposite().ref.oclIsUndefined())
	using {
--		enclosingSchema : JSchemaMM!ObjectSchema = requiredSchemaDefinition.refImmediateComposite();
		enclosingEClassName : String = if requiredSchemaDefinition.refImmediateComposite().hasSimpleTypeObject() then requiredSchemaDefinition.refImmediateComposite().resolve().name
										 else	requiredSchemaDefinition.refImmediateComposite().resolve().buildEClassNameForArrayOfTypes(#"\"object\"")
										 endif;
		required : Sequence(String) = requiredSchemaDefinition.required.values;
	}
	do{
		for (property in required) {
--			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName, enclosingSchema.resolve().name,  enclosingSchema.resolve().name+'Required', property);
			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName, enclosingEClassName,  enclosingEClassName+'Required', property);
		}
	}
}

lazy rule dependenciesArrayOcl{
	from dependenciesAdditionalPropertiesAnyOf2 : JSchemaMM!SchemaObjectDependenciesAdditionalPropertiesAnyOf2(dependenciesAdditionalPropertiesAnyOf2.refImmediateComposite().refImmediateComposite().refImmediateComposite().hasTypeObject())
	using {
		enclosingEClassName : String = if dependenciesAdditionalPropertiesAnyOf2.refImmediateComposite().refImmediateComposite().refImmediateComposite().hasSimpleTypeObject() then dependenciesAdditionalPropertiesAnyOf2.refImmediateComposite().refImmediateComposite().refImmediateComposite().resolve().name
										 else	dependenciesAdditionalPropertiesAnyOf2.refImmediateComposite().refImmediateComposite().refImmediateComposite().resolve().buildEClassNameForArrayOfTypes(#"\"object\"")
										 endif;	
		property : String = dependenciesAdditionalPropertiesAnyOf2.refImmediateComposite().key.stripFirstAndLast();
		values : Sequence(String) = dependenciesAdditionalPropertiesAnyOf2.anyOf2.values;
	}
	do{
		thisModule.appendDependenciesArrayOcl(thisModule.packageName, enclosingEClassName, enclosingEClassName+'DependenciesArray', property, values);
	}
}


--lazy rule requiredInPropertiesToOcl_old{
--	from requiredSchemaDefinition : JSchemaMM!RequiredSchemaDefinition
--	using {
--		enclosingSchema : JSchemaMM!ObjectSchema = requiredSchemaDefinition.refImmediateComposite();
--		required : Sequence(String) = requiredSchemaDefinition.required.values;
--		propertyName : String = enclosingSchema.getKey();
--		
--		inPropertiesRequiredKeySchemaPairs : Sequence(JSchemaMM!KeySchemaPair)= 
--			let propertiesSchemaDefinitions : Sequence(JSchemaMM!PropertiesSchemaDefinition) = 
--				enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!PropertiesSchemaDefinition))
--			in
--				if propertiesSchemaDefinitions.isEmpty() then Sequence{}
--				else
--					propertiesSchemaDefinitions->first().keySchemaPairs->select(ksp| required->includes(ksp.key.stripFirstAndLast()))
--				endif;
--				
--	
--		inPropertiesRequiredSchemas : Sequence(JSchemaMM!Schema)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.value);	
--		inPropertiesRequiredKeys : Sequence(String)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.key);	
--		requiredNotInProperties:Sequence(String) = required->excludingAll(inPropertiesRequiredKeys);
--	}
--	do{
--		for (p in inPropertiesRequiredKeySchemaPairs) {
--			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName, enclosingSchema.resolve().name,  enclosingSchema.resolve().name+'Required', p.key.stripFirstAndLast(), p.value.resolve().name, propertyName);
--		}
--	}
--}

lazy rule patternPropertiesRegexToOcl{
	---- keySchemaPair isInPatternProperties
	from keySchemaPair: JSchemaMM!KeySchemaPair(keySchemaPair.refImmediateComposite().oclIsTypeOf(JSchemaMM!PatternPropertiesSchemaDefinition))
	using {
		regex:String = keySchemaPair.key.stripFirstAndLast();
		contextClass:String = keySchemaPair.value.resolve().name ;
		inv : String = contextClass+keySchemaPair.value.getKey();
		propertyName : String = 'key';
	}
	do{
		
		thisModule.appendRegexInPatternPropertiesConstraint(thisModule.packageName,contextClass, inv, regex, propertyName);
	}
}

----------------- Derived Attributes
--rule createDerivedAttibutes(keySchemaPairs : Sequence(JSchemaMM!KeySchemaPair)){
rule createDerivedFeatures(objectSchema : JSchemaMM!ObjectSchema){
	using {
		derivedFeatures : Sequence(Ecore!EAttribute)= Sequence{};
		containmentPropertyName:String = objectSchema.getKeyForPropertiesContainment();
	}
	do{
		if(objectSchema.hasTypeObject()){ -----it has Type object, it is arrayOfTypes with object or type is missing
			if(not objectSchema.properties.oclIsUndefined()){
				for(keySchemaPair in objectSchema.properties.keySchemaPairs){
					if(keySchemaPair.value.hasSimpleTypeScalar()){
--						derivedFeatures <- derivedFeatures ->union(Sequence{thisModule.createDerivedAttibute(objectSchema.getKeyForPropertiesContainment(),keySchemaPair)});
						derivedFeatures <- derivedFeatures ->union(Sequence{thisModule.createDerivedAttibute(keySchemaPair.key.stripFirstAndLast(), keySchemaPair.value.resolve().getEStructuralFeature(keySchemaPair.key.stripFirstAndLast()).getEType(), thisModule.createGetterForDerivedFeature(containmentPropertyName, keySchemaPair))});
					}else if(keySchemaPair.value.hasSimpleTypeObject()){
--						derivedFeatures <- derivedFeatures ->union(Sequence{thisModule.createDerivedReference(objectSchema.getKeyForPropertiesContainment(),keySchemaPair)});
						derivedFeatures <- derivedFeatures ->union(Sequence{thisModule.createDerivedReference(keySchemaPair.key.stripFirstAndLast(),keySchemaPair.value.resolve(), thisModule.createGetterForDerivedReference(containmentPropertyName, keySchemaPair), 1)});
					}else if (keySchemaPair.value.hasSimpleTypeArray()){
--						derivedFeatures <- derivedFeatures -> union(Sequence{thisModule.createDerivedReferenceMappingTheKey(objectSchema.getKeyForPropertiesContainment(),keySchemaPair, -1)});
						derivedFeatures <- derivedFeatures -> union(Sequence{thisModule.createDerivedReference(keySchemaPair.key.stripFirstAndLast(), keySchemaPair.value.resolve().getEStructuralFeature(keySchemaPair.key.stripFirstAndLast()).getEType(), thisModule.createGetterForDerivedReferenceList(containmentPropertyName, keySchemaPair), -1)});
					}else if(keySchemaPair.value.hasSimpleTypeNull()){
--						derivedFeatures <- derivedFeatures -> union(Sequence{thisModule.createDerivedReferenceMappingTheKey(objectSchema.getKeyForPropertiesContainment(),keySchemaPair, 1)});
						derivedFeatures <- derivedFeatures -> union(Sequence{thisModule.createDerivedReference(keySchemaPair.key.stripFirstAndLast(),keySchemaPair.value.resolve().getEStructuralFeature(keySchemaPair.key.stripFirstAndLast()).getEType(), thisModule.createGetterForDerivedFeature(containmentPropertyName, keySchemaPair), 1)});
					}else if(keySchemaPair.value.hasArrayOfTypes or keySchemaPair.value.type.oclIsUndefined()){ --- if it hasArrayOfTypes it has Object for sure because of the condition on the enclosing if : hasTypeObject
--						derivedFeatures <- derivedFeatures -> union(Sequence{thisModule.createDerivedReferenceMappingTheKey(objectSchema.getKeyForPropertiesContainment(),keySchemaPair, 1)});
						derivedFeatures <- derivedFeatures -> union(Sequence{thisModule.createDerivedReference(keySchemaPair.key.stripFirstAndLast(),keySchemaPair.value.resolve().getEStructuralFeature(keySchemaPair.key.stripFirstAndLast()).getEType(), thisModule.createGetterForDerivedFeature(containmentPropertyName, keySchemaPair), 1)});
					}	
				} 
			}
		}
		derivedFeatures;
		
	}
}




rule createDerivedAttibute( key:String, eType:Ecore!EClassifier, getterValue:String){
--	using {
--		key:String =keySchemaPair.key.stripFirstAndLast();
--	}
	to
		derivedAttribute : Ecore!EAttribute(
--			name <- keySchemaPair.key.stripFirstAndLast(),
			name <- key,
			derived <- true,
--			eType <- keySchemaPair.value.resolve().getEStructuralFeature(key).getEType(),
			eType <- eType,
			changeable <- false,
			ordered <- false,
			unique <-false,
			lowerBound <- 0,
			upperBound <- 1, 
			transient <- true,
			volatile <- true,
			unsettable <- false,
			eAnnotations <- Sequence{eAnnotation}
		),
		eAnnotation: Ecore!EAnnotation(
			source <- 'http://www.eclipse.org/emf/2002/GenModel',
			details <- thisModule.createCommonAnnotationDetails()-> append(getter)
		),
		getter:Ecore!EStringToStringMapEntry(
			key <- 'get',
--			value <-  thisModule.createGetterForDerivedFeaturesMappingTheKey(propertyName, keySchemaPair)
			value <-  getterValue
		)
	do{
		derivedAttribute;
	}	
}

--rule createDerivedReference(propertyName:String, keySchemaPair : JSchemaMM!KeySchemaPair, upperBound:Integer) {
rule createDerivedReference(key:String, eType:Ecore!EClassifier, getterValue:String, upperBound:Integer ) {
--	using {
--		key:String =keySchemaPair.key.stripFirstAndLast();
--	}
	to
		derivedReference : Ecore!EReference(
			name <- key,
			derived <- true,
--			eType <- 	keySchemaPair.value.resolve(),
			eType <- eType,
			changeable <- false,
			ordered <- false,
			resolveProxies <- false,
			unique <-false,
			lowerBound <- 0,
--			upperBound <- 1, 
			upperBound <- upperBound, 
			transient <- true,
			volatile <- true,
			unsettable <- false,
			eAnnotations <- Sequence{eAnnotation}
		),
		eAnnotation: Ecore!EAnnotation(
			source <- 'http://www.eclipse.org/emf/2002/GenModel',
			details <- thisModule.createCommonAnnotationDetails()-> append(getter)
		),
		getter:Ecore!EStringToStringMapEntry(
			key <- 'get',
--			value <-  thisModule.createGetterForDerivedReference(propertyName, keySchemaPair)
			value <-  getterValue
		)
	do{
		derivedReference;
	}
}


rule createCommonAnnotationDetails(){
	
	to
		suppressedIsSetVisibility:Ecore!EStringToStringMapEntry(
			key <- 'suppressedIsSetVisibility',
			value <-  'true'
		),
		suppressedUnsetVisibility:Ecore!EStringToStringMapEntry(
			key <- 'suppressedUnsetVisibility',
			value <-  'true'
		),
		suppressedSetVisibility:Ecore!EStringToStringMapEntry(
			key <- 'suppressedSetVisibility',
			value <-  'true'
		),
		notify:Ecore!EStringToStringMapEntry(
			key <- 'notify',
			value <-  'false'
		),
		property:Ecore!EStringToStringMapEntry(
			key <- 'property',
			value <-  'Readonly'
		)
		
	do{
		Sequence {suppressedIsSetVisibility, suppressedUnsetVisibility, suppressedSetVisibility,notify,property};
	}	
	
}


rule createGetKeyOperation(propertyName:String, properties: Sequence(String), propertiesAbstractEClass : Ecore!EClass){
	to
		eOperation:Ecore!EOperation(
			name<- 'get',
			ordered <- false,
			unique <-false,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EJavaObject, 
			eParameters <- Sequence{eParameter},
			eAnnotations <- Sequence{eAnnotation}
		),
		eParameter:Ecore!EParameter(
			name<-'key',
			eType <- Ecore!EString,
			lowerBound <- 1,
			upperBound <- 1
		),
		eAnnotation: Ecore!EAnnotation(
			source <- 'http://www.eclipse.org/emf/2002/GenModel',
			details <- Sequence{entrySet}
		),
		entrySet:Ecore!EStringToStringMapEntry(
			key <- 'body',
			value <-  thisModule.createBodyForGetKey(propertyName, properties, propertiesAbstractEClass) 
		)
	do{
		eOperation;
	}
		
}



endpoint rule CompletEPackageAndJsonGrammar() {
	do {
		thisModule.packageRoot().eClassifiers <- thisModule.allEClass();	
		---- Json Grammar
		thisModule.jsonGrammarRoot().detailedGrammar.keywords <- thisModule.keywords;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesReferences <- thisModule.curlyBracesEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsReferences <- thisModule.bracketsEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.keyValue <- thisModule.keyValues;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesEClass <- thisModule.curlyBracesEClass;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsEClass <- thisModule.bracketsEClass;
		
		------ Related Schemas
		----- Dependencies
		for (dependenciesAdditionalPropertiesAnyOf1 in JSchemaMM!SchemaObjectDependenciesAdditionalPropertiesAnyOf1.allInstancesFrom('jschema')){
			thisModule.mapDependency(dependenciesAdditionalPropertiesAnyOf1);   
		}	
		thisModule.relatedSchemasRoot().enclosingschemas<-thisModule.enclosingSchemas;
		
		-----  Refine Class names for unicity	-----------
					
		for (eClass in thisModule.allEClass()){
			for (eClass2 in thisModule.allEClass()->excluding(eClass)->select(eClass2 | eClass2.name = eClass.name)) {
				eClass2.name <- eClass2.name.
					concat(thisModule.allEClass()->excluding(eClass)->select(eClass2 | eClass2.name = eClass.name)->indexOf(eClass2).toString());
			}
		}
		
		
		---- OCL generation--------
		for (m in JSchemaMM!MinimumSchemaDefinition.allInstancesFrom('jschema')){
			thisModule.minimumConstraintToOcl(m);
		}	
		
		for (m in JSchemaMM!ExclusiveMinimumSchemaDefinition.allInstancesFrom('jschema')){
			thisModule.exclusiveMinimumConstraintToOcl(m);
		}
		
		for (m in JSchemaMM!MaximumSchemaDefinition.allInstancesFrom('jschema')){
			thisModule.maximumConstraintToOcl(m);
		}

		for (r in JSchemaMM!RequiredSchemaDefinition.allInstancesFrom('jschema')){
--			if(r.refImmediateComposite().hasTypeObject() and r.refImmediateComposite().ref.oclIsUndefined()){
--				thisModule.requiredInPropertiesToOcl(r);
--			}	
			thisModule.requiredInPropertiesToOcl(r);
		}
		
		for(ksp in JSchemaMM!KeySchemaPair.allInstancesFrom('jschema')){
--			if(ksp.refImmediateComposite().oclIsTypeOf(JSchemaMM!PatternPropertiesSchemaDefinition)){
--				thisModule.patternPropertiesRegexToOcl(ksp);
--			}
			thisModule.patternPropertiesRegexToOcl(ksp);
		}
		
		for(dependenciesAdditionalPropertiesAnyOf2 in JSchemaMM!SchemaObjectDependenciesAdditionalPropertiesAnyOf2.allInstancesFrom('jschema')){
			thisModule.dependenciesArrayOcl(dependenciesAdditionalPropertiesAnyOf2);
		}
		
		------------------ Derived Attributes and operation get (String key)
		for(objectSchema in JSchemaMM!ObjectSchema.allInstancesFrom('jschema')){
			if(objectSchema.ref.oclIsUndefined()){ --- "$ref" is not present
				if(objectSchema.hasSimpleTypeObject()){
					if(not objectSchema.properties.oclIsUndefined()){
						objectSchema.resolve().eStructuralFeatures <- objectSchema.resolve().eStructuralFeatures-> union(thisModule.createDerivedFeatures(objectSchema));
					}
					
					objectSchema.resolve().eOperations <- objectSchema.resolve().eOperations-> union (Sequence{thisModule.createGetKeyOperation(objectSchema.getKeyForPropertiesContainment(),  objectSchema.findPropertiesKeys(), objectSchema.resolve().getEStructuralFeature(objectSchema.getKeyForPropertiesContainment()).getEType())});
					
				}else if(objectSchema.hasTypeObject()){--- if here surely not hasSimpleTypeObject. So it is missing type or "type":[...,"object",...]
					---- Look for subclass with annotation 'ArrayOfTypes'  = object
					if(not objectSchema.properties.oclIsUndefined()){
						objectSchema.resolve().getEStructuralFeature(objectSchema.getKey()).getEType().subClass(#"\"object\"").eStructuralFeatures <- objectSchema.resolve().getEStructuralFeature(objectSchema.getKey()).getEType().subClass(#"\"object\"").eStructuralFeatures-> union(thisModule.createDerivedFeatures(objectSchema));
					}
					------- for object in array of types we use objectSchema.getKey() and not objectSchema.getKeyForPropertiesContainment()
					objectSchema.resolve().getEStructuralFeature(objectSchema.getKey()).getEType().subClass(#"\"object\"").eOperations 
							<- objectSchema.resolve().getEStructuralFeature(objectSchema.getKey()).getEType().subClass(#"\"object\"").eOperations 
							-> union (Sequence{thisModule.createGetKeyOperation(objectSchema.getKeyForPropertiesContainment(),objectSchema.findPropertiesKeys(),  objectSchema.resolve().getEStructuralFeature(objectSchema.getKey()).getEType().subClass(#"\"object\"").getEStructuralFeature(objectSchema.getKeyForPropertiesContainment()).getEType())});
				
				}
			}
		}
		
		
		
		thisModule.endPackage();
		
	}
}

