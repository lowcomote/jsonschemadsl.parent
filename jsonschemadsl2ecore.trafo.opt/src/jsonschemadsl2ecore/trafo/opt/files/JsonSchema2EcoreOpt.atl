-- @atlcompiler emftvm
-- @nsURI JSchemaMM=http://at.jku.bise/jsonMetaschemaMM
-- @nsURI Ecore=http://www.eclipse.org/emf/2002/Ecore
-- @nsURI JsonGrammarMM=http://at.jku.bise/jsongrammar/1.0
-- @nsURI CompleteOclMM=http://www.eclipse.org/ocl/2015/CompleteOCLCS


module JsonSchema2EcoreOpt;
--create ecoreM : Ecore, jsonGrammar : JsonGrammarMM, jschemaOut: JSchemaMM from jschema : JSchemaMM;
create ecoreM : Ecore, jsonGrammar : JsonGrammarMM  from jschema : JSchemaMM;


uses JsonSchema2EcoreOptUtils;

helper def: rootEPackage : Ecore!EPackage = OclUndefined;
helper def: jsonDocumentStarter:String='jsonDocumentStarter';
helper def: packageName : String = thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().lastSegment();
helper def: nsURI : String = 'http://jku.bise.at/' + thisModule.packageName;

helper def: oclFileName:String  =thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().path().concat('-opt');
helper def: oclFileUri: OclAny = thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension();

rule JsonSchemaToEPackage {
	from
		jsonSchema : JSchemaMM!JsonSchema
	to 
		ePackage : Ecore!EPackage (
--			name <- jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			name <- thisModule.packageName,
--			nsPrefix <- jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			nsPrefix <- thisModule.packageName,
--			nsURI <- 'http://jku.bise.at/' + jsonSchema.eResource().getURI().trimFileExtension().lastSegment()
			nsURI <- thisModule.nsURI
		),
		jsonGrammar : JsonGrammarMM!JsonGrammar (
--			nsURI <- 'http://jku.bise.at/' + jsonSchema.eResource().getURI().trimFileExtension().lastSegment(),
			nsURI <- thisModule.nsURI,
			detailedGrammar <- detailedGrammar
		), 
		detailedGrammar : JsonGrammarMM!DetailedGrammar ()
	do {
		---------- Create ocl file -----
		thisModule.createOclFile();
	}
}

-----------------------NEW--------------------------

--rule mapRootBooleanSchemaTrueToJsonDocument{
--	from booleanSchema: JSchemaMM!BooleanSchema(booleanSchema.refImmediateComposite().oclIsTypeOf(JSchemaMM!JsonSchema) and booleanSchema.value=true)
--	to jsonDocument: JSchemaMM!JsonDocument
--}

abstract rule mapSchemaToEClass{ 
	from schema : JSchemaMM!Schema
	using {
--		eClassName:String = if schema.refImmediateComposite().oclIsTypeOf(JSchemaMM!ItemsAnyOf1) then schema.buildEClassname().concat('Items') else schema.buildEClassname() endif;
		eClassName:String = schema.buildEClassname(); ---we don't need to concat 'Items' because the class is being generated from the schema inside items. So the buildEClassname has alredy 'Items' concatenated
	}
	to 
		eClass : Ecore!EClass (
			name<- eClassName->debug('eClassName')
		)
	do{
		if(schema->debug('mapSchemaToEClass').isKeySchemaPairInProperties() or schema.isKeySchemaPairInPatternProperties() ){
			eClass.eSuperTypes <-  Sequence{thisModule.createAbstractEClass(schema.refImmediateComposite().refImmediateComposite().refImmediateComposite().buildPropertiesAbstractClassName())};
			thisModule.keywords <- thisModule.keywords->union(eClass.eStructuralFeatures) ;
		}else if(schema.refImmediateComposite().oclIsTypeOf(JSchemaMM!AdditionalPropertiesSchemaDefinition)){ ----- schema is in AdditionalProperties
			eClass.eAttributes <-  Sequence{thisModule.createKeyEAttribute('key')};
			eClass.eSuperTypes <-  Sequence{thisModule.createAbstractEClass(schema.refImmediateComposite().refImmediateComposite().buildPropertiesAbstractClassName() )};
		}
	}	
} 



rule mapBooleanSchemaToEClass extends mapSchemaToEClass{
--	from booleanSchema: JSchemaMM!BooleanSchema(not booleanSchema.refImmediateComposite().oclIsTypeOf(JSchemaMM!JsonSchema))
	from schema: JSchemaMM!BooleanSchema(not schema->debug('boolean schema').refImmediateComposite().oclIsTypeOf(JSchemaMM!JsonSchema) and schema.value=true)
	to 
		eClass : Ecore!EClass (
			eReferences  <- Sequence{thisModule.createContainmentToJsonDocument(schema.getKey()->debug('schema.getKey()'))}->debug('Sequence{thisModule.createContainmentToJsonDocument')
		)

}
			
rule mapObjectSchemaToEClass extends mapSchemaToEClass{
--	from objectSchema : JSchemaMM!ObjectSchema
	from schema : JSchemaMM!ObjectSchema
	to 
		eClass : Ecore!EClass(
			eReferences <- Sequence{}->debug('alessandro')
		)
	do{
		
		if(not schema.ref.oclIsUndefined()){
			eClass.eReferences <- Sequence{schema.ref->debug('mapObjectSchemaToEClass')};
		}else if (not schema.enum.oclIsUndefined()){
			----- TODO implement
		}else if (schema.type.oclIsUndefined()){  ---- "type" is missing
			----- TODO implement
		}else if(schema.hasSimpleType){
			if(schema.type.anyOf.type =  #"\"object\"" or schema.type.anyOf.type =  #"\"array\"" or schema.type.anyOf.type =  #"\"null\""){
--				eClass.eReferences <- Sequence{thisModule.mapSimpleTypeToEReference(schema, eClass.name, schema.type.anyOf.type )};
				eClass.eReferences <- Sequence{thisModule.mapSimpleTypeToEReference(eClass.name, schema.getKey(), schema.type.anyOf.type, schema.additionalProperties, schema.items )};
				
				
			}else{ 
--				eClass.eAttributes <- Sequence{thisModule.mapSimpleTypeToEAttribute(schema, eClass.name, schema.type.anyOf.type )};
				eClass.eAttributes <- Sequence{thisModule.mapScalarTypeToEAttribute(schema.getKey(),thisModule.scalarTypeMapping.get(schema.type.anyOf.type))};
			}
--			eClass.eStructuralFeatures <- Sequence{thisModule.mapSimpleTypeToEStructuralFeature(objectSchema, eClass.name, objectSchema.type.anyOf.type )};
		}	

--		else if (objectSchema.hasSimpleTypeScalar){ ---- "type" is present and ( "type": "integer" or "type": "number" or "type": "boolean" or "type": "string")
--			eClass.eStructuralFeatures <- Sequence{thisModule.mapScalarTypeToEAttribute(objectSchema.getKey(),objectSchema.type.getEDataType())};
--		}else if(objectSchema.hasSimpleTypeObject){  ----"type" is present and  "type": "object" 
--			eClass.eStructuralFeatures <-Sequence{thisModule.createPropertiesContainment(objectSchema.getKey, eClass.name.concat('Properties'))};
--			if(objectSchema.additionalProperties.oclIsUndefined()){ ------ additionalProperties missing
--				thisModule.createDefaultAdditionalPropertiesEClass(eClass.name);
--			}
--		}else if (objectSchema.hasSimpleTypeArray){ ----- "type" is present and  "type": "array"  
--			if(objectSchema.items.oclIsUndefined()) {---the keyword "items" is missing
--				eClass.eStructuralFeatures <- Sequence{thisModule.createEClassForMissingItems(objectSchema)};
--			}else { ---- the keyword "items" is present
--				eClass.eStructuralFeatures <- Sequence{objectSchema.items};
--			}
--		}else if(objectSchema.hasSimpleTypeNull){ ------- "type" is present and "type": "null"
--			----- TODO implement
--		}
		
		else if(schema.hasArrayOfTypes){ ----"type" is present and  is and array of "types" : "type":[...]
			----- TODO implement
			--------------------------
			for (sympleType in schema.type.items){ 
				
			}
			
			
		}
		eClass->debug('mapObjectSchemaToEClass.eClass.name');
	}
}


unique lazy rule mapSimpleTypeToEReference  {
	from eClassName : String, ----- objectSchema.buildEClassname() name of the EClass that is mapped to objectSchema having the "type" keyword
		key:String ,------  objectSchema.getKey()
		simpleType:String, ----- the simple type we are mapping to the eStructuralFeature
		additionalProperties:JSchemaMM!AdditionalPropertiesSchemaDefinition, --- objectSchema.additionalProperties  additionalProperties of objectSchema having the "type" keyword. It could be OclIsUndefined
		items:JSchemaMM!ItemsSchemaDefinition --- objectSchema.items items of objectSchema having the "type" keyword It could be OclIsUndefined
	to eReference : Ecore!EReference()
	do{ 
		if(simpleType = #"\"object\"" ){   
			eReference = thisModule.createPropertiesContainment(key->debug('mapSimpleTypeToEStructuralFeature:objectSchema.getKey'), eClassName.concat('Properties')->debug('eClassName'+eClassName));
			if(additionalProperties.oclIsUndefined()){ ------ additionalProperties missing
				thisModule.createDefaultAdditionalPropertiesEClass(eClassName);
			}
--		}else if (objectSchema.hasSimpleTypeArray){ ----- "type" is present and  "type": "array"  
		}else if (simpleType = #"\"array\""){ ----- "type" is present and  "type": "array"  	
			if(items.oclIsUndefined()) {---the keyword "items" is missing
--				eStructuralFeature =  thisModule.createEClassForMissingItems(objectSchema);
				eReference =  thisModule.createEClassForMissingItems(eClassName, key);
			}else if(items.anyOf.oclIsTypeOf(JSchemaMM!ItemsAnyOf1)){ ---- the keyword "items" is present and is not a tuple
				
				eReference = items.anyOf.anyOf1;
			}else{ ---- the keyword "items" is present and is a tuple
				-----TODO Implement
			}
		}else if(simpleType = #"\"null\""){ ------- "type" is present and "type": "null"
			----- TODO implement
		}
	}
}

--unique lazy  rule mapSimpleTypeToEReference extends mapSimpleTypeToEStructuralFeature{
--	from objectSchema : JSchemaMM!ObjectSchema,  ----- objectSchema having the type keyword
--		eClassName : String, ----- name of the EClass that is mapped to objectSchema
--		simpleType:String ----- the simple type we are mapping to the eStructuralFeature
--	to eReference : Ecore!EReference
--}

--unique lazy  rule mapSimpleTypeToEAttribute extends mapSimpleTypeToEStructuralFeature{
--	from objectSchema : JSchemaMM!ObjectSchema,  ----- objectSchema having the type keyword
--		eClassName : String, ----- name of the EClass that is mapped to objectSchema
--		simpleType:String ----- the simple type we are mapping to the eStructuralFeature
--	to eAttribute : Ecore!EAttribute
--}


---- this rule map a simple type to a feature. It has to be called if objectSchema.hasSimpleType (it has a type and it is a simple one)
--lazy abstract rule mapSimpleTypeToEStructuralFeature{ 
----	from key:String, simpleType:String, eClassName : String
--	from objectSchema : JSchemaMM!ObjectSchema,  ----- objectSchema having the type keyword
--		eClassName : String, ----- name of the EClass that is mapped to objectSchema having the "type" keyword
--		simpleType:String ----- the simple type we are mapping to the eStructuralFeature
--		
--		
--	to 
--		eStructuralFeature : Ecore!EStructuralFeature
--
--	do { 
----		if (objectSchema.hasSimpleTypeScalar){ ---- "type" is present and ( "type": "integer" or "type": "number" or "type": "boolean" or "type": "string")
--		if (thisModule.isScalar(simpleType)){ 	
----			eStructuralFeature <- thisModule.mapScalarTypeToEAttribute(objectSchema.getKey(),objectSchema.type.getEDataType());
--			eStructuralFeature = thisModule.mapScalarTypeToEAttribute(objectSchema.getKey(),thisModule.scalarTypeMapping.get(simpleType));
----		}else if(objectSchema.hasSimpleTypeObject){  ----"type" is present and  "type": "object" 
--		}else if(simpleType = #"\"object\"" ){   
--			eStructuralFeature = thisModule.createPropertiesContainment(objectSchema.getKey()->debug('mapSimpleTypeToEStructuralFeature:objectSchema.getKey'), eClassName.concat('Properties')->debug('eClassName'+eClassName));
--			if(objectSchema.additionalProperties.oclIsUndefined()){ ------ additionalProperties missing
--				thisModule.createDefaultAdditionalPropertiesEClass(eClassName);
--			}
----		}else if (objectSchema.hasSimpleTypeArray){ ----- "type" is present and  "type": "array"  
--		}else if (simpleType = #"\"array\""){ ----- "type" is present and  "type": "array"  	
--			if(objectSchema.items.oclIsUndefined()) {---the keyword "items" is missing
----				eStructuralFeature =  thisModule.createEClassForMissingItems(objectSchema);
--				eStructuralFeature =  thisModule.createEClassForMissingItems(eClassName, objectSchema.getKey());
--			}else if(objectSchema.items.anyOf.oclIsTypeOf(JSchemaMM!ItemsAnyOf1)){ ---- the keyword "items" is present and is not a tuple
--				
--				eStructuralFeature = objectSchema.items.anyOf.anyOf1;
--			}else{ ---- the keyword "items" is present and is a tuple
--				-----TODO Implement
--			}
--		}else if(simpleType = #"\"null\""){ ------- "type" is present and "type": "null"
--			----- TODO implement
--		}
--	}
--	
--}
	

lazy rule mapScalarTypeToEAttribute{
	from name : String, eType:Ecore!EDataType
	to 
		eAttribute : Ecore!EAttribute(
			name<-name,
			lowerBound <-1,
			upperBound <- 1,
			eType <- eType
		)
}



lazy rule createPropertiesContainment{
	--from typeSchemaDefinition: JSchemaMM!TypeSchemaDefinition (typeSchemaDefinition.findSimpleType() = #"\"object\"")	
	from referenceName:String, propertiesEClassName:String
	to 
		eReference :Ecore!EReference ( 
--			name <- typeSchemaDefinition.refImmediateComposite().getKey(),
			name <- referenceName,
--			eType <- thisModule.createAbstractEClass(typeSchemaDefinition.refImmediateComposite().buildEClassname().concat('Properties')),
			eType <- thisModule.createAbstractEClass(propertiesEClassName),
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
			
		)
	do {
		thisModule.curlyBracesEReferences <- thisModule.curlyBracesEReferences->union(Sequence{eReference}); 
	}	
}
lazy rule createDefaultAdditionalPropertiesEClass  {
	from schemaBuildedClassName:String
	to
		eClass : Ecore!EClass (
		 	name <-	schemaBuildedClassName.concat('AdditionalProperties'),
			eStructuralFeatures <- Set{thisModule.createKeyEAttribute('key'), thisModule.createContainmentToJsonDocument('additionalProperties')}.flatten(),
			eSuperTypes <-  Set{thisModule.createAbstractEClass(schemaBuildedClassName.concat('Properties'))}
		)
}

rule mapItemsAnyOf1ToContainment{
	from itemsAnyOf1:JSchemaMM!ItemsAnyOf1
	to 
		eReference :Ecore!EReference ( 
			name <- itemsAnyOf1.refImmediateComposite().refImmediateComposite().getKey(),
			eType <- itemsAnyOf1.anyOf1,
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
		)
	do{
		thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
	}
}


lazy rule createEClassForMissingItems{
--	from enclosingObjectSchema:JSchemaMM!ObjectSchema
	from enclosingEClassName:String, referenceName:String
	to 
		eClass:  Ecore!EClass (
--			name <- enclosingObjectSchema.buildEClassname().concat('Items'),
			name <- enclosingEClassName.concat('Items'),
			eStructuralFeatures <- Sequence{thisModule.createContainmentToJsonDocument(('items'))}
		),
		eReference :Ecore!EReference ( 
--			name <- enclosingObjectSchema.getKey(),
			name <- referenceName,
			eType <- eClass,
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
		)
	do{
		thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
	}
	
}
--rule mapItemsToEClass{
--	from items:JSchemaMM!ItemsSchemaDefinition(items.anyOf.oclIsTypeOf(JSchemaMM!ItemsAnyOf1))----- "items" is not a tuple
--	to 
--		eReference :Ecore!EReference ( 
--			name <- items.refImmediateComposite().getKey(),
--			eType <- items.anyOf.anyOf1,
--			containment <- true,
--			lowerBound <- 0,
--			upperBound <- -1
--		)
--	do{
--		thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
--		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
--	}
--}

--lazy rule createEClassForMissingItems{
--	from enclosingObjectSchema:JSchemaMM!ObjectSchema
--	to 
--		eClass:  Ecore!EClass (
--			name <- enclosingObjectSchema.buildEClassname().concat('Items'),
--			eStructuralFeatures <- Sequence{thisModule.createContainmentToJsonDocument(('items'))}
--		),
--		eReference :Ecore!EReference ( 
--			name <- enclosingObjectSchema.getKey(),
--			eType <- eClass,
--			containment <- true,
--			lowerBound <- 0,
--			upperBound <- -1
--		)
--	do{
--		thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
--		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
--	}
--	
--}



---- This rule creates an EClass for a type list in the array of types
--lazy rule createEClassForTypeInArrayOfTypes{
----	from objectSchema :JSchemaMM!ObjectSchema, simpleType :String, superEClass : Ecore!EClass
--	from 
--		objectSchema : JSchemaMM!ObjectSchema,  ----- objectSchema having the type keyword
--		eClassName : String, ----- name of the EClass that is mapped to objectSchema
--		simpleType:String ----- current simpleType in the array of types which we are creating the EClass for
--	to 
--		eClass : Ecore!EClass (
--			 eSuperTypes <- Sequence{thisModule.createAbstractEClass(eClassName.concat('Type'))}, 
--			 eStructuralFeatures  <- Sequence{thisModule.mapSimpleTypeToEStructuralFeature(objectSchema, eClassName , simpleType )}
--
--		)
--	do{ 
--		if(not objectSchema.isRootOrDefinitionOrSchemaObjectAdditionalProperties()){ 
--			eClass.eSuperTypes.eSuperTypes <- Sequence{thisModule.createAbstractEClass(eClassName.concat('Properties'))};
--		}
--	}
--		
--		
--		
--}


--abstract rule mapAdditionalPropertiesEClass {
--	from additionalPropertiesSchemaDefinition : JSchemaMM!AdditionalPropertiesSchemaDefinition
--	using {
--		additionalPropertiesName : String = additionalPropertiesSchemaDefinition.additionalProperties.buildEClassname();
--		propertiesEClassName : String = 	additionalPropertiesSchemaDefinition.refImmediateComposite().buildEClassname().concat('Properties');
--	}
--	to
--		eClass : Ecore!EClass (
--		 	name <-	additionalPropertiesName->debug('additionalPropertiesName'),
--			eSuperTypes <-  Set{thisModule.createAbstractEClass(propertiesEClassName)}
--		)
--}
--
--rule mapObjectSchemaAdditionalPropertiesEClass extends mapAdditionalPropertiesEClass{
--	from additionalPropertiesSchemaDefinition : JSchemaMM!AdditionalItemsSchemaDefinition(additionalPropertiesSchemaDefinition.additionalProperties.oclIsTypeOf(JSchemaMM!ObjectSchema))
--	using {
--		additionalPropertiesObjectSchema : JSchemaMM!ObjectSchema = additionalPropertiesSchemaDefinition.additionalProperties;
--	}
--	to
--		eClass : Ecore!EClass (
--			eStructuralFeatures <- Sequence{
--										thisModule.createKeyEAttribute('key'),
--										if not additionalPropertiesObjectSchema.ref.oclIsUndefined() then additionalPropertiesObjectSchema.ref 
--										else additionalPropertiesObjectSchema.additionalProperties 
--										endif
--									}.flatten() 
--		),
--		key : Ecore!EAttribute		
--}
--
--rule mapBooleanSchemaAdditionalPropertiesEClass extends mapAdditionalPropertiesEClass{
--	from additionalPropertiesSchemaDefinition : JSchemaMM!AdditionalPropertiesSchemaDefinition (
--		additionalPropertiesSchemaDefinition.additionalProperties.oclIsTypeOf(JSchemaMM!BooleanSchema) and 
--		additionalPropertiesSchemaDefinition.additionalProperties.value=true
--	)
--	to
--		eClass : Ecore!EClass (
--			eAttributes <-  Sequence{thisModule.createKeyEAttribute('key')->debug('thisModule.createKeyEAttribute')},
--			eReferences <- Sequence{thisModule.createContainmentToJsonDocument('additionalProperties')}
----			eStructuralFeatures <- Sequence{thisModule.createKeyEAttribute('key'), thisModule.createContainmentToJsonDocument('additionalProperties')}.flatten()
--		)
--}

lazy rule createKeyEAttribute{
	from keyName:String 
	to 
	key : Ecore!EAttribute(
			name<- keyName->debug('keyName'),
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EString
	) 
	do {
		key->debug('createKeyEAttribute');
		thisModule.keyValues <- thisModule.keyValues->union(Sequence{key});
	}
}

lazy rule  createContainmentToJsonDocument{
	from containmentName:String 
	to
		containment: Ecore!EReference(
			name <- containmentName,
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- JSchemaMM!JsonDocument
		)
	do{ 
		containment->debug('createContainmentToJsonDocument');
	}
}

---------------------------------------------------------------------
---------------------------------------------------------------------
-----------------------------------------------------------------------



---- TODO manage jsonPointerSchema.hasArrayOfTypes
rule mapRefSchemaToEReference{
	from refSchemaDefinition: JSchemaMM!RefSchemaDefinition 
	using {
        jsonPointerSchema : JSchemaMM!Schema = refSchemaDefinition.findSchemaByJsonPointer();
        isJsonPointerSchemaTypeArray : Boolean = 	if jsonPointerSchema.oclIsTypeOf(JSchemaMM!ObjectSchema) then 
--														if jsonPointerSchema.keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition)).first().findSimpleType() = #"\"array\""
														if jsonPointerSchema.hasSimpleTypeArray
														then true else false endif
													else false
													endif ;
	} to		
		eReference :Ecore!EReference ( 
			name <- refSchemaDefinition.refImmediateComposite().getKey()->debug('ref key'),
--			eType <- refSchemaDefinition.findSchemaByJsonPointer().oclAsType(JSchemaMM!ObjectSchema),
			eType <- refSchemaDefinition.findSchemaByJsonPointer()->debug('ref jsonpointer'),
			containment <- true, 
			lowerBound <- 1,
			upperBound <- 1			
		)
	do {
		if (isJsonPointerSchemaTypeArray){ 
			thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
		}	
	}	
}

--- This is the old :unique lazy rule createPropertiesEClass{ we change the name because we reuse for more 'properties'
unique lazy rule createAbstractEClass{
	from name:String
	to
		eClass : Ecore!EClass (
			name <- name.concat('Abstract'),
			abstract<- true
		)	
}

-------------------- OCL Generation --------------------------------

lazy rule minimumConstraintToOcl {
	from minimumSchemaDefinition : JSchemaMM!MinimumSchemaDefinition
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = minimumSchemaDefinition.refImmediateComposite();
	}
	do {
--		thisModule.appendMinimumConstraint(thisModule.packageName+'::'+enclosingSchema.buildEClassname(), enclosingSchema.buildEClassname()+'Minimum', minimumSchemaDefinition.minimum);
		thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().name, enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
	}
}


lazy rule requiredInPropertiesToOcl{
	from requiredSchemaDefinition : JSchemaMM!RequiredSchemaDefinition
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = requiredSchemaDefinition.refImmediateComposite();
		required : Sequence(String) = requiredSchemaDefinition.required.values;
		propertyName : String = enclosingSchema.getKey();
		
		inPropertiesRequiredKeySchemaPairs : Sequence(JSchemaMM!KeySchemaPair)= 
			let propertiesSchemaDefinitions : Sequence(JSchemaMM!PropertiesSchemaDefinition) = 
				enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!PropertiesSchemaDefinition))
			in
				if propertiesSchemaDefinitions.isEmpty() then Sequence{}
				else
					propertiesSchemaDefinitions->first().keySchemaPairs->select(ksp| required->includes(ksp.key.stripFirstAndLast()))
				endif;
				
	
		inPropertiesRequiredSchemas : Sequence(JSchemaMM!Schema)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.value);	
		inPropertiesRequiredKeys : Sequence(String)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.key);	
		requiredNotInProperties:Sequence(String) = required->excludingAll(inPropertiesRequiredKeys);
	}
	do{
		for (p in inPropertiesRequiredKeySchemaPairs) {
--			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName+'::'+enclosingSchema.buildEClassname(), enclosingSchema.buildEClassname()+'Required', p.key.stripFirstAndLast(), p.value.buildEClassname());
			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName, enclosingSchema.resolve().name,  enclosingSchema.resolve().name+'Required', p.key.stripFirstAndLast(), p.value.resolve().name, propertyName);
		}
	}
}

lazy rule patternPropertiesRegexToOcl{
	---- keySchemaPair isInPatternProperties
	from keySchemaPair: JSchemaMM!KeySchemaPair(keySchemaPair.refImmediateComposite().oclIsTypeOf(JSchemaMM!PatternPropertiesSchemaDefinition))
	using {
		regex:String = keySchemaPair.key.stripFirstAndLast();
		contextClass:String = keySchemaPair.value.resolve().name ;
		inv : String = contextClass+keySchemaPair.value.getKey();
		propertyName : String = 'key';
	}
	do{
		
		thisModule.appendRegexInPatternPropertiesConstraint(thisModule.packageName,contextClass, inv, regex, propertyName);
	}
}



endpoint rule CompletEPackageAndJsonGrammar() {
	do {
		thisModule.packageRoot().eClassifiers <- thisModule.allEClass();	
		---- Json Grammar
		thisModule.jsonGrammarRoot().detailedGrammar.keywords <- thisModule.keywords;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesReferences <- thisModule.curlyBracesEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsReferences <- thisModule.bracketsEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.keyValue <- thisModule.keyValues;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesEClass <- thisModule.curlyBracesEClass;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsEClass <- thisModule.bracketsEClass;
		
		
		-----  Refine Class names for unicity	-----------
		

					
		for (eClass in thisModule.allEClass()){
			for (eClass2 in thisModule.allEClass()->excluding(eClass)->select(eClass2 | eClass2.name = eClass.name)) {
				eClass2.name <- eClass2.name.
					concat(thisModule.allEClass()->excluding(eClass)->select(eClass2 | eClass2.name = eClass.name)->indexOf(eClass2).toString());
			}
		}
		
		
		---- OCL generation--------
		for (m in JSchemaMM!MinimumSchemaDefinition.allInstancesFrom('jschema')){
			thisModule.minimumConstraintToOcl(m);
		}	

		for (r in JSchemaMM!RequiredSchemaDefinition.allInstancesFrom('jschema')){
			thisModule.requiredInPropertiesToOcl(r);
		}
		
		for(ksp in JSchemaMM!KeySchemaPair.allInstancesFrom('jschema')){
			if(ksp.refImmediateComposite().oclIsTypeOf(JSchemaMM!PatternPropertiesSchemaDefinition)){
				thisModule.patternPropertiesRegexToOcl(ksp);
			}
		}
			
		thisModule.endPackage();
		
	}
}

