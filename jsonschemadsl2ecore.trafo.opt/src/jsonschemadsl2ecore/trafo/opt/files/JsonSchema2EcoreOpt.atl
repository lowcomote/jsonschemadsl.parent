-- @atlcompiler emftvm
-- @nsURI JSchemaMM=http://at.jku.bise/jsonMetaschemaMM
-- @nsURI Ecore=http://www.eclipse.org/emf/2002/Ecore
-- @nsURI JsonGrammarMM=http://at.jku.bise/jsongrammar/1.0
-- @nsURI CompleteOclMM=http://www.eclipse.org/ocl/2015/CompleteOCLCS


module JsonSchema2EcoreOpt;
--create ecoreM : Ecore, jsonGrammar : JsonGrammarMM, jschemaOut: JSchemaMM from jschema : JSchemaMM;
create ecoreM : Ecore, jsonGrammar : JsonGrammarMM  from jschema : JSchemaMM;


uses JsonSchema2EcoreOptUtils;

helper def: rootEPackage : Ecore!EPackage = OclUndefined;
helper def: jsonDocumentStarter:String='jsonDocumentStarter';
helper def: packageName : String = thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().lastSegment();
helper def: nsURI : String = 'http://jku.bise.at/' + thisModule.packageName;

helper def: oclFileName:String  =thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension().path().concat('-opt');
helper def: oclFileUri: OclAny = thisModule.retrieveRootSchema().eResource().getURI().trimFileExtension();

rule JsonSchemaToEPackage {
	from
		jsonSchema : JSchemaMM!JsonSchema
	to 
		ePackage : Ecore!EPackage (
			name <- thisModule.packageName,
			nsPrefix <- thisModule.packageName,
			nsURI <- thisModule.nsURI
		),
		jsonGrammar : JsonGrammarMM!JsonGrammar (
			nsURI <- thisModule.nsURI,
			detailedGrammar <- detailedGrammar
		), 
		detailedGrammar : JsonGrammarMM!DetailedGrammar ()
	do {
		---------- Create ocl file -----
		thisModule.createOclFile();
	}
}

-----------------------NEW--------------------------

--rule mapRootBooleanSchemaTrueToJsonDocument{
--	from booleanSchema: JSchemaMM!BooleanSchema(booleanSchema.refImmediateComposite().oclIsTypeOf(JSchemaMM!JsonSchema) and booleanSchema.value=true)
--	to jsonDocument: JSchemaMM!JsonDocument
--}

abstract rule mapSchemaToEClass{ 
	from schema : JSchemaMM!Schema
	using {
		eClassName:String = schema.buildEClassname(); ---we don't need to concat 'Items' because the class is being generated from the schema inside items. So the buildEClassname has alredy 'Items' concatenated
	}
	to 
		eClass : Ecore!EClass (
			name<- eClassName,
			eStructuralFeatures <- eClass.eStructuralFeatures 
				-> union (	if schema.isInAdditionalProperties()  or schema.isKeySchemaPairInPatternProperties()
							then Sequence{thisModule.createKeyEAttribute('key')}
							else Sequence{}
							endif)
		)
	do{
		if(schema.isKeySchemaPairInProperties() or schema.isKeySchemaPairInPatternProperties() ){
			eClass.eSuperTypes <-  Sequence{thisModule.createAbstractEClass(schema.refImmediateComposite().refImmediateComposite().refImmediateComposite().buildPropertiesAbstractClassName())};
		}else if(schema.refImmediateComposite().oclIsTypeOf(JSchemaMM!AdditionalPropertiesSchemaDefinition)){ ----- schema is in AdditionalProperties
			eClass.eSuperTypes <-  Sequence{thisModule.createAbstractEClass(schema.refImmediateComposite().refImmediateComposite().buildPropertiesAbstractClassName() )};
		}
	}	
} 

rule mapBooleanSchemaToEClass extends mapSchemaToEClass{
	from schema: JSchemaMM!BooleanSchema(not schema.refImmediateComposite().oclIsTypeOf(JSchemaMM!JsonSchema) and schema.value=true)
	to 
		eClass : Ecore!EClass
	do{ --- we have to assign eStructuralFeatures in the imperative block, because the union wouldn't work, if a part if different features are added from the two targets of the abstract and concrete rule
		eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createContainmentToJsonDocument(schema.getKey(), schema.isKeySchemaPairInProperties())});
	}
}
			
rule mapObjectSchemaToEClass extends mapSchemaToEClass{
	from schema : JSchemaMM!ObjectSchema
	to 
		eClass : Ecore!EClass
	do{ 
		if(not schema.ref.oclIsUndefined()){ --- "$ref" is present
			eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{schema.ref});
		}else if (not schema.enum.oclIsUndefined()){ --- "enum" is present
			----- TODO implement
		}else if (schema.type.oclIsUndefined()){  ---- "type" is missing
			----- TODO implement
		}else if(schema.hasSimpleType()){
			thisModule.mapSimpleTypeToEStructuralFeatures(schema, eClass , schema.type.anyOf.type, eClass.name); 
		}else if(schema.hasArrayOfTypes){ ----"type" is present and  is and array of "types" : "type":[...]
			----- TODO implement
			--------------------------
			eClass.abstract<- true;
			for (sympleType in schema.type.anyOf.items){ 
				thisModule.createEClassForTypeInArrayOfTypes(schema, eClass , sympleType);
			}
		}
	}
}
---- schema objectSchema having the "type" keyword
---- eClass  -----  EClass that is mapped to objectSchema having the "type" keyword
---- simpleType:JSchemaMM!SimpleTypes, ----- the simple type we are mapping to the eStructuralFeature
----- eClassName eClass.name. It could be thant eClass.name is not set yet
rule mapSimpleTypeToEStructuralFeatures(schema : JSchemaMM!ObjectSchema, eClass : Ecore!EClass, simpleType:JSchemaMM!SimpleTypes, eClassName:String)  {
	
	do{
		
		if (simpleType = #"\"string\"" or simpleType = #"\"integer\"" or simpleType = #"\"number\"" or  simpleType = #"\"boolean\""){ 
--			eClass.eStructuralFeatures  <- eClass.eStructuralFeatures -> union(Sequence{thisModule.mapScalarTypeToEAttribute(schema.getKey(),thisModule.scalarTypeMapping.get(schema.type.anyOf.type), schema.isKeySchemaPairInProperties())});
			eClass.eStructuralFeatures  <- eClass.eStructuralFeatures -> union(Sequence{thisModule.mapScalarTypeToEAttribute(schema.getKey(),thisModule.scalarTypeMapping.get(simpleType), schema.isKeySchemaPairInProperties())});
		}else if(simpleType = #"\"object\"" ){
			eClass.name->debug('mapSimpleTypeToEStructuralFeatures: eClass.name');
--			eClass.eStructuralFeatures <- eClass.eStructuralFeatures-> union(Sequence{thisModule.createPropertiesContainment(schema.getKey(), eClass.name.concat('Properties'), schema.isKeySchemaPairInProperties())});
--			eClass.eStructuralFeatures <- eClass.eStructuralFeatures-> union(Sequence{thisModule.createPropertiesContainment(schema.getKey(), eClassName.concat('Properties'), schema.isKeySchemaPairInProperties())});
			eClass.eStructuralFeatures <- eClass.eStructuralFeatures-> union(Sequence{thisModule.createPropertiesContainment(schema.getKey(), schema.buildPropertiesAbstractClassName(), schema.isKeySchemaPairInProperties())});
			if(schema.additionalProperties.oclIsUndefined()){ ------ the keyword "additionalProperties" is missing
--				thisModule.createDefaultAdditionalPropertiesEClass(eClass.name);
				thisModule.createDefaultAdditionalPropertiesEClass(eClassName);
			}
		}else if (simpleType = #"\"array\""){  
			if(schema.items.oclIsUndefined()) {---the keyword "items" is missing
--				eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createEClassForMissingItems(eClass.name, schema.getKey())});
				eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{thisModule.createEClassForMissingItems(eClassName, schema.getKey())});
			}else if(schema.items.anyOf.oclIsTypeOf(JSchemaMM!ItemsAnyOf1)){ ---- the keyword "items" is present and is not a tuple
				eClass.eStructuralFeatures <- eClass.eStructuralFeatures -> union(Sequence{schema.items.anyOf});
			}else{ ---- the keyword "items" is present and is a tuple 
				-----TODO Implement
			}
		}else if(simpleType = #"\"null\""){ ------- "type" is present and "type": "null"
			----- TODO implement
		}
	}
}

lazy rule mapScalarTypeToEAttribute{
	from name : String, eType:Ecore!EDataType, addToKeywords:Boolean
	to 
		eAttribute : Ecore!EAttribute(
			name<-name,
			lowerBound <-1,
			upperBound <- 1,
			eType <- eType
		)
	do{ 
		if(addToKeywords){ 
			thisModule.keywords <- thisModule.keywords->union(Sequence{eAttribute}) ;
		}
		eAttribute;
	}
}

lazy rule createPropertiesContainment{
	from referenceName:String, propertiesEClassName:String, addToKeywords:Boolean
	to 
		eReference :Ecore!EReference ( 
			name <- referenceName,
			eType <- thisModule.createAbstractEClass(propertiesEClassName),
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
			
		)
	do {
		thisModule.curlyBracesEReferences <- thisModule.curlyBracesEReferences->union(Sequence{eReference}); 
		if(addToKeywords){ 
			thisModule.keywords <- thisModule.keywords->union(Sequence{eReference}) ;
		}
		eReference;
	}	
}

lazy rule createDefaultAdditionalPropertiesEClass  {
	from schemaBuildedClassName:String
	to
		eClass : Ecore!EClass (
		 	name <-	schemaBuildedClassName.concat('AdditionalProperties'),
			eStructuralFeatures <- Set{thisModule.createKeyEAttribute('key'), thisModule.createContainmentToJsonDocument('additionalProperties',false)}.flatten(),
			eSuperTypes <-  Set{thisModule.createAbstractEClass(schemaBuildedClassName.concat('Properties'))}
		)
}

rule mapItemsAnyOf1ToContainment{
	from itemsAnyOf1:JSchemaMM!ItemsAnyOf1
	to 
		eReference :Ecore!EReference ( 
			name <- itemsAnyOf1.refImmediateComposite().refImmediateComposite().getKey()->debug('mapItemsAnyOf1ToContainment:getKey'),
			eType <- itemsAnyOf1.anyOf1,
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
		)
	do{
		thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
	}
}

lazy rule createEClassForMissingItems{
	from enclosingEClassName:String, referenceName:String
	to 
		eClass:  Ecore!EClass (
			name <- enclosingEClassName.concat('Items'),
			eStructuralFeatures <- Sequence{thisModule.createContainmentToJsonDocument(('items'),false)}
		),
		eReference :Ecore!EReference ( 
			name <- referenceName,
			eType <- eClass,
			containment <- true,
			lowerBound <- 0,
			upperBound <- -1
		)
	do{
		thisModule.keywords <- thisModule.keywords->union(Sequence{eReference});
		thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
		eReference;
	}
	
}



----- objectSchema: objectSchema having the type keyword
----- enclosingEClass:  name of the EClass that is mapped to objectSchema
----- simpleType: current simpleType in the array of types which we are creating the EClass for
rule createEClassForTypeInArrayOfTypes(objectSchema : JSchemaMM!ObjectSchema, enclosingEClass : Ecore!EClass , simpleType:JSchemaMM!SimpleTypes){
	using {
		eClassName:String = enclosingEClass.name.concat('Type').concat(thisModule.typeToStringMapping.get(simpleType).toCamelCase())->debug('enclosingEClass.name.concat(thisModule.typeToStringMapping.get(simpleType).toCamelCase())');
	}
	to 
		eClass : Ecore!EClass (
--			name <- enclosingEClass.name.concat(thisModule.typeToStringMapping.get(simpleType).toCamelCase())->debug('enclosingEClass.name.concat(thisModule.typeToStringMapping.get(simpleType).toCamelCase())')
			name <- eClassName
--			 eSuperTypes <- Sequence{thisModule.createAbstractEClass(enclosingEClass.name.concat('Type'))}, 
--			 eStructuralFeatures  <- Sequence{thisModule.mapSimpleTypeToEStructuralFeatures(objectSchema, enclosingEClass , simpleType ->debug('createEClassForTypeInArrayOfTypes:sympleType') )}
		)
	do{
		eClass.name->debug('createEClassForTypeInArrayOfTypes::eClass.name');
		thisModule.mapSimpleTypeToEStructuralFeatures(objectSchema, eClass , simpleType, eClassName);
--		thisModule.mapSimpleTypeToEStructuralFeatures(objectSchema, enclosingEClass , simpleType);
--		eClass.eSuperTypes  <- Sequence{thisModule.createAbstractTypeEClass(enclosingEClass.name, not objectSchema.isRootOrDefinitionOrSchemaObjectAdditionalProperties())};
		eClass.eSuperTypes  <- Sequence{enclosingEClass};
--		if(not objectSchema.isRootOrDefinitionOrSchemaObjectAdditionalProperties()){ 
--			eClass.eSuperTypes.first().eSuperTypes <- Sequence{thisModule.createAbstractEClass(enclosingEClass.name.concat('Properties'))};
--		}
	}
}	

--rule createKeyEAttribute(keyName:String){
lazy rule createKeyEAttribute{
	from keyName:String 
	to 
		key : Ecore!EAttribute(
			name<- keyName,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- Ecore!EString
	) 
	do {
		thisModule.keyValues <- thisModule.keyValues->union(Sequence{key});
		key;
	}
}

lazy rule  createContainmentToJsonDocument{
	from containmentName:String,  addToKeywords:Boolean
	to
		containment: Ecore!EReference(
			name <- containmentName,
			containment <- true,
			lowerBound <- 1,
			upperBound <- 1,
			eType <- JSchemaMM!JsonDocument
		)
	do{ 
		if(addToKeywords){ 
			thisModule.keywords <- thisModule.keywords->union(Sequence{containment});
		}
		containment;
	}
}

---------------------------------------------------------------------
---------------------------------------------------------------------
-----------------------------------------------------------------------

---- TODO manage jsonPointerSchema.hasArrayOfTypes
rule mapRefSchemaToEReference{
	from refSchemaDefinition: JSchemaMM!RefSchemaDefinition 
	using {
        jsonPointerSchema : JSchemaMM!Schema = refSchemaDefinition.findSchemaByJsonPointer();
        isJsonPointerSchemaTypeArray : Boolean = 	if jsonPointerSchema.oclIsTypeOf(JSchemaMM!ObjectSchema) then 
--														if jsonPointerSchema.keywordDefinition->select(keywordDefinition | keywordDefinition.oclIsTypeOf(JSchemaMM!TypeSchemaDefinition)).first().findSimpleType() = #"\"array\""
														if jsonPointerSchema.hasSimpleTypeArray()
														then true else false endif
													else false
													endif ;
	} to		
		eReference :Ecore!EReference ( 
			name <- refSchemaDefinition.refImmediateComposite().getKey(),
--			eType <- refSchemaDefinition.findSchemaByJsonPointer().oclAsType(JSchemaMM!ObjectSchema),
			eType <- refSchemaDefinition.findSchemaByJsonPointer(),
			containment <- true, 
			lowerBound <- 1,
			upperBound <- 1			
		)
	do {
		if (isJsonPointerSchemaTypeArray){ 
			thisModule.bracketsEReferences <- thisModule.bracketsEReferences->union(Sequence{eReference});
		}if(refSchemaDefinition.refImmediateComposite().isKeySchemaPairInProperties()) { 
			thisModule.keywords <- thisModule.keywords->union(Sequence{eReference}) ;
		}
	}	
}

--- This is the old :unique lazy rule createPropertiesEClass{ we change the name because we reuse for more 'properties'
unique lazy rule createAbstractEClass{
	from name:String
	to
		eClass : Ecore!EClass (
			name <- name.concat('Abstract'),
			abstract<- true
		)	
}

--unique lazy rule createAbstractTypeEClass{
--	from name:String, setSuperType:Boolean
--	to
--		eClass : Ecore!EClass (
--			name <- name.concat('TypeAbstract'),
--			eSuperTypes <- if setSuperType then Sequence{thisModule.createAbstractEClass(name.concat('Properties'))}
--						   else Sequence{}	 endif,
--			abstract<- true
--		)	
----	do{ 
----		if(setSuperType){ 
----			eClass.eSuperTypes <-Sequence{thisModule.createAbstractEClass(name.concat('Properties'))};
----		}
----		eClass;
----	}
--}

-------------------- OCL Generation --------------------------------

lazy rule minimumConstraintToOcl {
	from minimumSchemaDefinition : JSchemaMM!MinimumSchemaDefinition
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = minimumSchemaDefinition.refImmediateComposite();
	}
	do {
--		thisModule.appendMinimumConstraint(thisModule.packageName+'::'+enclosingSchema.buildEClassname(), enclosingSchema.buildEClassname()+'Minimum', minimumSchemaDefinition.minimum);
		thisModule.appendMinimumConstraint(thisModule.packageName, enclosingSchema.resolve().name, enclosingSchema.resolve().name+'Minimum', minimumSchemaDefinition.minimum, enclosingSchema.getKey());
	}
}


lazy rule requiredInPropertiesToOcl{
	from requiredSchemaDefinition : JSchemaMM!RequiredSchemaDefinition
	using {
		enclosingSchema : JSchemaMM!ObjectSchema = requiredSchemaDefinition.refImmediateComposite();
		required : Sequence(String) = requiredSchemaDefinition.required.values;
		propertyName : String = enclosingSchema.getKey();
		
		inPropertiesRequiredKeySchemaPairs : Sequence(JSchemaMM!KeySchemaPair)= 
			let propertiesSchemaDefinitions : Sequence(JSchemaMM!PropertiesSchemaDefinition) = 
				enclosingSchema.keywordDefinition->select(k|k.oclIsTypeOf(JSchemaMM!PropertiesSchemaDefinition))
			in
				if propertiesSchemaDefinitions.isEmpty() then Sequence{}
				else
					propertiesSchemaDefinitions->first().keySchemaPairs->select(ksp| required->includes(ksp.key.stripFirstAndLast()))
				endif;
				
	
		inPropertiesRequiredSchemas : Sequence(JSchemaMM!Schema)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.value);	
		inPropertiesRequiredKeys : Sequence(String)= inPropertiesRequiredKeySchemaPairs->collect(ksp | ksp.key);	
		requiredNotInProperties:Sequence(String) = required->excludingAll(inPropertiesRequiredKeys);
	}
	do{
		for (p in inPropertiesRequiredKeySchemaPairs) {
--			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName+'::'+enclosingSchema.buildEClassname(), enclosingSchema.buildEClassname()+'Required', p.key.stripFirstAndLast(), p.value.buildEClassname());
			thisModule.appendRequiredInPropertiesConstraint(thisModule.packageName, enclosingSchema.resolve().name,  enclosingSchema.resolve().name+'Required', p.key.stripFirstAndLast(), p.value.resolve().name, propertyName);
		}
	}
}

lazy rule patternPropertiesRegexToOcl{
	---- keySchemaPair isInPatternProperties
	from keySchemaPair: JSchemaMM!KeySchemaPair(keySchemaPair.refImmediateComposite().oclIsTypeOf(JSchemaMM!PatternPropertiesSchemaDefinition))
	using {
		regex:String = keySchemaPair.key.stripFirstAndLast();
		contextClass:String = keySchemaPair.value.resolve().name ;
		inv : String = contextClass+keySchemaPair.value.getKey();
		propertyName : String = 'key';
	}
	do{
		
		thisModule.appendRegexInPatternPropertiesConstraint(thisModule.packageName,contextClass, inv, regex, propertyName);
	}
}



endpoint rule CompletEPackageAndJsonGrammar() {
	do {
		thisModule.packageRoot().eClassifiers <- thisModule.allEClass();	
		---- Json Grammar
		thisModule.jsonGrammarRoot().detailedGrammar.keywords <- thisModule.keywords;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesReferences <- thisModule.curlyBracesEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsReferences <- thisModule.bracketsEReferences;
		thisModule.jsonGrammarRoot().detailedGrammar.keyValue <- thisModule.keyValues;		
		thisModule.jsonGrammarRoot().detailedGrammar.curlyBracesEClass <- thisModule.curlyBracesEClass;
		thisModule.jsonGrammarRoot().detailedGrammar.bracketsEClass <- thisModule.bracketsEClass;
		
		
		-----  Refine Class names for unicity	-----------
		

					
		for (eClass in thisModule.allEClass()){
			for (eClass2 in thisModule.allEClass()->excluding(eClass)->select(eClass2 | eClass2.name = eClass.name)) {
				eClass2.name <- eClass2.name.
					concat(thisModule.allEClass()->excluding(eClass)->select(eClass2 | eClass2.name = eClass.name)->indexOf(eClass2).toString());
			}
		}
		
		
		---- OCL generation--------
		for (m in JSchemaMM!MinimumSchemaDefinition.allInstancesFrom('jschema')){
			thisModule.minimumConstraintToOcl(m);
		}	

		for (r in JSchemaMM!RequiredSchemaDefinition.allInstancesFrom('jschema')){
			thisModule.requiredInPropertiesToOcl(r);
		}
		
		for(ksp in JSchemaMM!KeySchemaPair.allInstancesFrom('jschema')){
			if(ksp.refImmediateComposite().oclIsTypeOf(JSchemaMM!PatternPropertiesSchemaDefinition)){
				thisModule.patternPropertiesRegexToOcl(ksp);
			}
		}
			
		thisModule.endPackage();
		
	}
}

